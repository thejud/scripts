#!/usr/bin/env ruby

require 'optparse'
require 'logger'
require 'find'

$log=Logger.new STDERR

########################################
# FUNCTIONS
########################################

EXCLUDES = %W{
  ^\..*\.sw.$
}
PATH_EXCLUDES = %W{
  /\.git/
}

def parse_args
  o = {}
  OptionParser.new do |opts|
    opts.banner = "Usage: #{File.basename(__FILE__)} [options]"
    opts.on("-h", "--help", "Show help") do
     puts opts
     exit
    end
    opts.on("-q", "--quiet", "Quiet. Decrease verbosity only. Can be repeated") do
      o[:quiet] ||= 0
      o[:quiet] += 1 if o[:quiet] < 2
    end
    opts.on("-p", "--path", "Match full path, not just basename") do 
      o[:path] = true
    end
    opts.on("-d", "--dir", "Match directories, not just files") do
      o[:dirs] = true
    end
    opts.on("-a", "--all", "match all files, even the excluded ones") do
      o[:all] = true
    end
    opts.on("-1", "--first", "stop at first match") do
      o[:first] = true
    end
    opts.on("-e", "--edit", "open files in $EDITOR") do
      o[:edit] = true
    end
  end.parse!
  return o
end

def editor
  ENV['VISUAL'] || ENV['EDITOR'] || 'vi'
end

def capture f
  @files << f
end

def main
  opts = parse_args

  if File.basename($0).end_with? '1'
    opts[:first] = true
    # alias as "ff1" or something similar to trigger first find behavior
  end
  if File.basename($0).start_with? 'v'
    # alias as vff to trigger open in editor
    opts[:editor] = true
  end

  @files = []

  pattern = ARGV.shift || '.'
  dirs = ARGV
  dirs << '.' if dirs.empty?

  pattern = Regexp.new(pattern)
  excludes = Regexp.new( EXCLUDES.map { |s| "(#{s})"}.join('|') )
  path_excludes = Regexp.new( PATH_EXCLUDES.map { |s| "(#{s})"}.join('|') )

  Find.find(*dirs) do |path|
    next if FileTest.directory?(path) unless opts[:dirs]
    basename = File.basename(path)

    if opts[:all]
      next if excludes.match(basename)
      next if path_excludes.match(path)
    end

    name = opts[:path] ? path : basename
    if pattern.match(name)
      capture(path) if opts[:edit] 
      puts path
      break if opts[:first]
    end
  end

  if opts[:edit] and !@files.empty?
    warn [editor, *@files].join(" ")
    exec(editor, *@files)
  end
end

########################################
# MAIN BODY
########################################

if __FILE__ == $0    # this script can be required as a library
  main
end
